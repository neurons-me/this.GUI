# Declarative GUI with `this.GUI`
`this.GUI` is designed as a **declarative layout system**, where all building blocks (NavBar, Drawers, StickyOptions, Footer) expose **clear JSON-friendly props**.  
This **allows UIs to be described** and even generated by tools like **LLMs**, using nothing more than structured data.

---

## üîë Core Idea
- Every component exposes a **schema-like props API**.
- Layout respects **insets** (nav height, drawer widths) reported into the theme via `CustomThemeProvider`.
- The provider also mirrors these values into CSS variables (`--gui-inset-left`, `--gui-inset-right`, `--gui-nav-height`).
- With this contract, GUIs can be built from **JSON specs** instead of imperative React code.

Example JSON spec:

```json
{
  "route": "/dashboard",
  "layout": {
    "navbar": { "title": "Dashboard", "position": "fixed" },
    "stickyOptions": {
      "items": [
        { "icon": "mui:BarChart", "label": "Stats", "href": "/stats" },
        { "icon": "lucide:bolt", "label": "Power", "href": "/power" }
      ]
    },
    "drawerLeft": { "title": "Menu", "items": [...] },
    "drawerRight": { "title": "Context", "items": [...] },
    "footer": { "text": "¬© 2025 neurons.me" }
  }
}

Your renderer simply hydrates this into React components.


---

## üì¶ Components

### NavBar

**Props:**
- `title`: string
- `logo`: string (URL)
- `NavBarLinks`: array of `{ label, href, icon?, children? }`
- `position`: `"fixed"` | `"static"` | `"sticky"` (default: `"fixed"`)
- `showMenuButton`, `showThemeToggle`

NavBar measures its height and updates `theme.layout.insets.nav`.

```jsx
<NavBar title="Demo" position="fixed" />
```

---

### LeftDrawer & RightDrawer

**Props:**
- `drawerWidth`: number (default: 260)
- `variant`: `"permanent"` | `"temporary"` (auto-chooses based on screen size)
- `title`: optional with label + icon

Each drawer updates `theme.layout.insets.left` or `theme.layout.insets.right` when permanent.

```jsx
<LeftDrawer title="Menu" items={[{ icon: 'mui:Home', label: 'Home' }]} />
<RightDrawer title="Context" items={[{ icon: 'mui:Info', label: 'Details' }]} />
```

---

### StickyOptionsTop

Compact quick-actions bar that lives under the NavBar.

**Props:**
- `items`: actions `{ icon, label?, href?, iconColor?, variant? }`
- `positioning`: `{ mode: 'sticky' | 'fixed', topOffset, reserveSpace }`
- `mobileVariant`: `"auto"` | `"fab"` | `"inline"`
- `dense`: boolean

```jsx
<StickyOptionsTop
  items={[
    { icon: 'mui:Settings', label: 'Settings', href: '/settings' },
    { icon: 'lucide:bolt', label: 'Power', href: '/power', iconColor: 'primary' }
  ]}
  positioning={{ mode: 'sticky' }}
/>
```

---

### Footer

**Props:**
- `text`: string or ReactNode
- Automatically respects left/right insets from permanent drawers.

```jsx
<Footer text="¬© 2025 neurons.me" />
```

---

## üåê Why Declarative?

Every prop is JSON-serializable, so LLMs or external systems can generate full UIs declaratively:
- ‚ÄúAdd a right drawer with a title and an insights icon‚Äù
- ‚ÄúPlace a sticky options bar under the navbar with capture + settings‚Äù
- ‚ÄúOn /reports, show the drawer and a compact navbar‚Äù

These map directly into JSON specs that your app hydrates into React.

---

## üöÄ Benefits
- **Schema-driven:** easy to serialize, validate, and diff.
- **LLM-ready:** prompt-to-UI becomes natural.
- **Layout-safe:** insets keep everything aligned automatically.
- **Composable:** any route can declare its layout in one object.

---

## Example: Full Route Layout

```jsx
<NavBar title="Dashboard" />
<LeftDrawer title="Menu" />
<StickyOptionsTop items={items} />
<PageContent />
<Footer text="¬© 2025 neurons.me" />
```

Or as JSON:

```json
{
  "navbar": { "title": "Dashboard" },
  "drawerLeft": { "title": "Menu" },
  "stickyOptions": { "items": [ ... ] },
  "footer": { "text": "¬© 2025 neurons.me" }
}
```

---
That‚Äôs the philosophy: declarative contracts for every GUI building block, so your UI can be described, generated, and remixed by humans, scripts, or LLMs.
---

